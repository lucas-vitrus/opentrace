/*
 * This program source code file is part of Trace, an AI-native PCB design application.
 *
 * Copyright The Trace Developers, see TRACE_AUTHORS.txt for contributors.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef AI_BACKEND_CLIENT_H
#define AI_BACKEND_CLIENT_H

#include <kicommon.h>
#include <ai_diff_analyzer.h>
#include <string>
#include <functional>
#include <atomic>
#include <memory>
#include <optional>
#include <utility>
#include <nlohmann/json.hpp>

class AI_TOOL_EXECUTOR;

/**
 * Event types received from the AI backend.
 */
enum class AI_EVENT_TYPE
{
    TEXT_DELTA,        ///< Partial text content
    STATUS,            ///< Status message (tool calls, etc.)
    TITLE_UPDATE,      ///< Conversation title generated by LLM
    MODE_TRANSITION,   ///< Mode changed (e.g., plan -> agent for execution)
    PHASE_UPDATE,      ///< Workflow phase changed (for UI state updates)
    TOOL_CALL,         ///< Tool call request from backend
    FILE_EDIT,         ///< File edit completed
    PROGRESS,          ///< Progress update
    EVENT_ERROR,       ///< Error message (renamed from ERROR to avoid Windows macro conflict)
    AUTH_ERROR,        ///< Authentication error (401)
    QUOTA_EXCEEDED,    ///< Quota/usage limit exceeded (402)
    PLAN_RESTRICTED,   ///< Feature requires paid plan (403)
    DONE,              ///< Stream completed
    VERSIONS_LIST,     ///< List of file versions
    VERSION_SAVED,     ///< Version saved confirmation
    VERSION_RESTORED   ///< Version restored confirmation
};

/**
 * Event data from the AI backend.
 */
struct KICOMMON_API AI_BACKEND_EVENT
{
    AI_EVENT_TYPE  type;
    std::string    content;
    nlohmann::json data;
    std::string    toolName;
    nlohmann::json toolArgs;
    std::string    toolCallId;
    bool           fileModified;
    std::string    conversationId;
    std::string    versionId;
    std::string    error;

    // Mode transition info (for MODE_TRANSITION events)
    std::string    fromMode;       ///< Previous mode (e.g., "plan")
    std::string    toMode;         ///< New mode (e.g., "agent")
    std::string    transitionReason; ///< Why the transition happened (e.g., "plan_execution")

    // Diff analysis for incremental updates
    DIFF_RESULT    diffInfo;       ///< Diff analysis result (for FILE_EDIT events)
    bool           hasDiffInfo;    ///< True if diffInfo was computed
    std::string    diffType;       ///< "incremental" or "full_reload"

    AI_BACKEND_EVENT() : type( AI_EVENT_TYPE::TEXT_DELTA ), fileModified( false ), hasDiffInfo( false ) {}
};

/**
 * Result of a streaming request.
 */
struct KICOMMON_API AI_STREAM_RESULT
{
    std::string response;       ///< Full accumulated response
    std::string status;         ///< "success", "error", "stopped", "auth_error"
    bool        fileModified;   ///< True if file was modified during stream
    std::string error;          ///< Error message if status is "error"
    std::string conversationId; ///< Conversation ID from backend
    int         eventCount;     ///< Number of SSE events received (for debugging)

    AI_STREAM_RESULT() : fileModified( false ), eventCount( 0 ) {}
};

/**
 * User quota/plan information from the backend.
 * 
 * Cost-based billing: Users are billed by actual USD cost, not request count.
 * Daily/monthly caps based on plan type.
 */
struct KICOMMON_API USER_QUOTA_INFO
{
    bool        success;            ///< True if quota fetch succeeded
    bool        allowed;            ///< True if user can make requests
    std::string plan;               ///< Current plan (e.g., "trial", "free", "pro_monthly")
    std::string code;               ///< Quota code (e.g., "TRIAL_ACTIVE", "DAILY_COST_LIMIT_REACHED")
    std::string reason;             ///< Human-readable reason
    
    // Cost-based billing fields (NEW)
    double      dailyCostUsed;      ///< Cost used today in USD
    double      dailyCostCap;       ///< Daily cost cap in USD (-1 for unlimited)
    double      monthlyCostUsed;    ///< Cost used this month in USD
    double      monthlyCostCap;     ///< Monthly cost cap in USD (-1 for unlimited)
    
    // Trial info
    int         trialHoursLeft;     ///< Hours remaining in trial (-1 if not in trial)
    bool        isTrial;            ///< True if user is in trial period
    
    // Credit-based plans (on-demand)
    int         creditsRemaining;   ///< Credits remaining for on-demand plans (-1 if not applicable)
    
    // Legacy fields (DEPRECATED - kept for backward compatibility)
    int         dailyLimit;         ///< DEPRECATED: Daily request limit
    int         dailyUsage;         ///< DEPRECATED: Requests used today

    USER_QUOTA_INFO() : success( false ), allowed( false ), 
                        dailyCostUsed( 0.0 ), dailyCostCap( -1.0 ),
                        monthlyCostUsed( 0.0 ), monthlyCostCap( -1.0 ),
                        trialHoursLeft( -1 ), isTrial( false ),
                        creditsRemaining( -1 ),
                        dailyLimit( 0 ), dailyUsage( 0 ) {}
};

/**
 * Client for direct communication with the AI backend.
 * 
 * Handles SSE streaming, tool execution, and authentication.
 * Replaces the Python local client for direct C++ to backend communication.
 */
class KICOMMON_API AI_BACKEND_CLIENT
{
public:
    /**
     * Construct the backend client.
     * @param aBackendUrl The backend server URL.
     */
    explicit AI_BACKEND_CLIENT( const std::string& aBackendUrl );
    ~AI_BACKEND_CLIENT();

    /**
     * Set the backend URL.
     */
    void SetBackendUrl( const std::string& aUrl ) { m_backendUrl = aUrl; }

    /**
     * Get the backend URL.
     */
    std::string GetBackendUrl() const { return m_backendUrl; }

    /**
     * Set the tool executor for handling tool calls.
     */
    void SetToolExecutor( AI_TOOL_EXECUTOR* aExecutor ) { m_toolExecutor = aExecutor; }

    /**
     * Set event callback for streaming events.
     * Called for each event received from the backend.
     */
    void SetEventCallback( std::function<void( const AI_BACKEND_EVENT& )> aCallback )
    {
        m_eventCallback = aCallback;
    }

    /**
     * Stream a chat request to the backend.
     * 
     * @param aMessage User message.
     * @param aFilePath Path to the trace file (optional).
     * @param aKicadFilePath Path to the corresponding KiCad file (optional).
     * @param aSessionId Session ID for continuity.
     * @param aConversationId Existing conversation ID (optional).
     * @param aMode AI mode ("ask", "plan", "agent").
     * @param aAppType Application type ("eeschema" or "pcbnew").
     * @param aAuthToken JWT auth token (optional).
     * @param aRefreshToken Refresh token (optional).
     * @return Stream result with accumulated response and status.
     */
    AI_STREAM_RESULT StreamChat( const std::string& aMessage,
                                 const std::string& aFilePath = "",
                                 const std::string& aKicadFilePath = "",
                                 const std::string& aSessionId = "",
                                 const std::string& aConversationId = "",
                                 const std::string& aMode = "ask",
                                 const std::string& aAppType = "eeschema",
                                 const std::string& aAuthToken = "",
                                 const std::string& aRefreshToken = "" );

    /**
     * Stop the current streaming request.
     */
    void StopStream();

    /**
     * Check if a stream is currently active.
     */
    bool IsStreaming() const { return m_isStreaming.load(); }

    /**
     * Submit a tool result back to the backend.
     * @param aSessionId Session ID.
     * @param aToolCallId Tool call ID.
     * @param aResult Tool execution result.
     * @param aAuthToken Auth token (optional).
     * @return True if submission succeeded.
     */
    bool SubmitToolResult( const std::string& aSessionId,
                           const std::string& aToolCallId,
                           const std::string& aResult,
                           const std::string& aAuthToken = "" );

    /**
     * Save a schematic version to the database.
     * @param aFilePath Path to the trace file.
     * @param aDescription Description of the version.
     * @param aConversationId Conversation ID to link to.
     * @param aAuthToken Auth token.
     * @param aSchematicContent Optional content (reads from file if empty).
     * @return Version ID if successful, empty string otherwise.
     */
    std::string SaveSchematicVersion( const std::string& aFilePath,
                                      const std::string& aDescription,
                                      const std::string& aConversationId,
                                      const std::string& aAuthToken,
                                      const std::string& aSchematicContent = "" );

    /**
     * Get list of schematic versions.
     * @param aFilePath Path to the trace file.
     * @param aAuthToken Auth token.
     * @param aLimit Maximum versions to return.
     * @return JSON array of version records.
     */
    nlohmann::json GetSchematicVersions( const std::string& aFilePath,
                                         const std::string& aAuthToken,
                                         int                aLimit = 50 );

    /**
     * Restore a schematic to a previous version.
     * @param aVersionId Version ID to restore.
     * @param aFilePath Path to write restored content.
     * @param aAuthToken Auth token.
     * @return True if successful.
     */
    bool RestoreSchematicVersion( const std::string& aVersionId,
                                  const std::string& aFilePath,
                                  const std::string& aAuthToken );

    /**
     * Get user quota information from the backend.
     * @param aAuthToken Auth token.
     * @return Quota info struct with plan, limits, and usage.
     */
    USER_QUOTA_INFO GetUserQuota( const std::string& aAuthToken );

private:
    /**
     * Parse SSE event from a line.
     * @param aLine SSE line (starts with "data: ").
     * @return Parsed event, or empty optional if not a data line.
     */
    std::optional<AI_BACKEND_EVENT> parseSSEEvent( const std::string& aLine );

    /**
     * Process a parsed event.
     * Handles tool calls, emits callbacks, etc.
     * @return True if file was modified by this event.
     */
    bool processEvent( AI_BACKEND_EVENT& aEvent,
                       const std::string& aFilePath,
                       const std::string& aKicadFilePath,
                       const std::string& aSessionId,
                       const std::string& aAuthToken );

    /**
     * Convert KiCad file to trace format.
     * Called when trace file is missing or empty before sending a request.
     * Uses popen for thread-safe execution from background threads.
     * @param aKicadFilePath Path to the source KiCad file.
     * @param aTraceFilePath Path to the output trace file.
     * @param aAppType Application type ("eeschema" or "pcbnew").
     * @return Pair of (success, error_message).
     */
    std::pair<bool, std::string> syncKicadToTrace( const std::string& aKicadFilePath,
                                                    const std::string& aTraceFilePath,
                                                    const std::string& aAppType );

    std::string              m_backendUrl;
    AI_TOOL_EXECUTOR*        m_toolExecutor;
    std::atomic<bool>        m_isStreaming;
    std::atomic<bool>        m_stopRequested;

    std::function<void( const AI_BACKEND_EVENT& )> m_eventCallback;
};

#endif // AI_BACKEND_CLIENT_H

